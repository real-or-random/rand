var N = null;var searchIndex = {};
searchIndex["rand"]={"doc":"Utilities for random number generation","items":[[8,"RngCore","rand","The core of a random number generator.",N,N],[10,"next_u32","","Return the next random `u32`.",0,[[["self"]],["u32"]]],[10,"next_u64","","Return the next random `u64`.",0,[[["self"]],["u64"]]],[10,"fill_bytes","","Fill `dest` with random data.",0,N],[10,"try_fill_bytes","","Fill `dest` entirely with random data.",0,N],[8,"CryptoRng","","A marker trait used to indicate that an [`RngCore`] or [`BlockRngCore`] implementation is supposed to be cryptographically secure.",N,N],[8,"SeedableRng","","A random number generator that can be explicitly seeded.",N,N],[16,"Seed","","Seed type, which is restricted to types mutably-dereferencable as `u8` arrays (we recommend `[u8; N]` for some `N`).",1,N],[10,"from_seed","","Create a new PRNG using the given seed.",1,N],[11,"from_rng","","Create a new PRNG seeded from another `Rng`.",1,[[["r"]],["result",["error"]]]],[4,"ErrorKind","","Error kind which can be matched over.",N,N],[13,"Unavailable","","Feature is not available; not recoverable.",2,N],[13,"Unexpected","","General failure; there may be a chance of recovery on retry.",2,N],[13,"Transient","","A transient failure which likely can be resolved or worked around.",2,N],[13,"NotReady","","Not ready yet: recommended to try again a little later.",2,N],[3,"Error","","Error type of random number generators",N,N],[12,"kind","","The error kind",3,N],[12,"msg","","The error message",3,N],[5,"thread_rng","","Retrieve the lazily-initialized thread-local random number generator, seeded by the system. Intended to be used in method chaining style, e.g. `thread_rng().gen::<i32>()`, or cached locally, e.g. `let mut rng = thread_rng();`.",N,[[],["threadrng"]]],[5,"random","","Generates a random value using the thread-local random number generator.",N,[[],["t"]]],[0,"distributions","","Generating random samples from probability distributions.",N,N],[3,"Alphanumeric","rand::distributions","Sample a `char`, uniformly distributed over ASCII letters and numbers: a-z, A-Z and 0-9.",N,N],[3,"Uniform","","Sample values uniformly between two bounds.",N,N],[3,"OpenClosed01","","A distribution to sample floating point numbers uniformly in the half-open interval `(0, 1]`, i.e. including 1 but not 0.",N,N],[3,"Open01","","A distribution to sample floating point numbers uniformly in the open interval `(0, 1)`, i.e. not including either endpoint.",N,N],[3,"Bernoulli","","The Bernoulli distribution.",N,N],[3,"WeightedIndex","","A distribution using weighted sampling to pick a discretely selected item.",N,N],[3,"UnitSphereSurface","","Samples uniformly from the surface of the unit sphere in three dimensions.",N,N],[3,"UnitCircle","","Samples uniformly from the edge of the unit circle in two dimensions.",N,N],[3,"Gamma","","The Gamma distribution `Gamma(shape, scale)` distribution.",N,N],[3,"ChiSquared","","The chi-squared distribution `χ²(k)`, where `k` is the degrees of freedom.",N,N],[3,"FisherF","","The Fisher F distribution `F(m, n)`.",N,N],[3,"StudentT","","The Student t distribution, `t(nu)`, where `nu` is the degrees of freedom.",N,N],[3,"Beta","","The Beta distribution with shape parameters `alpha` and `beta`.",N,N],[3,"Normal","","The normal distribution `N(mean, std_dev**2)`.",N,N],[3,"LogNormal","","The log-normal distribution `ln N(mean, std_dev**2)`.",N,N],[3,"StandardNormal","","Samples floating-point numbers according to the normal distribution `N(0, 1)` (a.k.a. a standard normal, or Gaussian). This is equivalent to `Normal::new(0.0, 1.0)` but faster.",N,N],[3,"Exp","","The exponential distribution `Exp(lambda)`.",N,N],[3,"Exp1","","Samples floating-point numbers according to the exponential distribution, with rate parameter `λ = 1`. This is equivalent to `Exp::new(1.0)` or sampling with `-rng.gen::<f64>().ln()`, but faster.",N,N],[3,"Pareto","","Samples floating-point numbers according to the Pareto distribution",N,N],[3,"Poisson","","The Poisson distribution `Poisson(lambda)`.",N,N],[3,"Binomial","","The binomial distribution `Binomial(n, p)`.",N,N],[3,"Cauchy","","The Cauchy distribution `Cauchy(median, scale)`.",N,N],[3,"Dirichlet","","The dirichelet distribution `Dirichlet(alpha)`.",N,N],[3,"Triangular","","The triangular distribution.",N,N],[3,"Weibull","","Samples floating-point numbers according to the Weibull distribution",N,N],[3,"DistIter","","An iterator that generates random values of `T` with distribution `D`, using `R` as the source of randomness.",N,N],[3,"Standard","","A generic random value distribution, implemented for many primitive types. Usually generates values with a numerically uniform distribution, and with a range appropriate to the type.",N,N],[3,"Weighted","","A value with a particular weight for use with `WeightedChoice`.",N,N],[12,"weight","","The numerical weight of this item",4,N],[12,"item","","The actual item which is being weighted",4,N],[3,"WeightedChoice","","A distribution that selects from a finite collection of weighted items.",N,N],[4,"WeightedError","","Error type returned from `WeightedIndex::new`.",N,N],[13,"NoItem","","The provided iterator contained no items.",5,N],[13,"NegativeWeight","","A weight lower than zero was used.",5,N],[13,"AllWeightsZero","","All items in the provided iterator had a weight of zero.",5,N],[0,"uniform","","A distribution uniformly sampling numbers within a given range.",N,N],[3,"Uniform","rand::distributions::uniform","Sample values uniformly between two bounds.",N,N],[3,"UniformInt","","The back-end implementing [`UniformSampler`] for integer types.",N,N],[3,"UniformFloat","","The back-end implementing [`UniformSampler`] for floating-point types.",N,N],[3,"UniformDuration","","The back-end implementing [`UniformSampler`] for `Duration`.",N,N],[8,"SampleUniform","","Helper trait for creating objects using the correct implementation of [`UniformSampler`] for the sampling type.",N,N],[16,"Sampler","","The `UniformSampler` implementation supporting type `X`.",6,N],[8,"UniformSampler","","Helper trait handling actual uniform sampling.",N,N],[16,"X","","The type sampled by this implementation.",7,N],[10,"new","","Construct self, with inclusive lower bound and exclusive upper bound `[low, high)`.",7,[[["b1"],["b2"]],["self"]]],[10,"new_inclusive","","Construct self, with inclusive bounds `[low, high]`.",7,[[["b1"],["b2"]],["self"]]],[10,"sample","","Sample a value.",7,N],[11,"sample_single","","Sample a single value uniformly from a range with inclusive lower bound and exclusive upper bound `[low, high)`.",7,N],[8,"SampleBorrow","","Helper trait similar to [`Borrow`] but implemented only for SampleUniform and references to SampleUniform in order to resolve ambiguity issues.",N,N],[10,"borrow","","Immutably borrows from an owned value. See [`Borrow::borrow`]",8,[[["self"]],["borrowed"]]],[11,"clone","","",9,[[["self"]],["uniform"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `Uniform` instance which samples uniformly from the half open range `[low, high)` (excluding `high`). Panics if `low >= high`.",9,[[["b1"],["b2"]],["uniform"]]],[11,"new_inclusive","","Create a new `Uniform` instance which samples uniformly from the closed range `[low, high]` (inclusive). Panics if `low > high`.",9,[[["b1"],["b2"]],["uniform"]]],[11,"sample","","",9,[[["self"],["r"]],["x"]]],[11,"from","","",9,[[["range"]],["uniform"]]],[11,"from","","",9,[[["rangeinclusive"]],["uniform"]]],[11,"clone","","",10,[[["self"]],["uniformint"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"clone","","",11,[[["self"]],["uniformfloat"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"clone","","",12,[[["self"]],["uniformduration"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"new","","",12,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",12,[[["b1"],["b2"]],["self"]]],[11,"sample","","",12,[[["self"],["r"]],["duration"]]],[11,"clone","rand::distributions","",13,[[["self"]],["bernoulli"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Bernoulli` with the given probability of success `p`.",13,[[["f64"]],["bernoulli"]]],[11,"from_ratio","","Construct a new `Bernoulli` with the probability of success of `numerator`-in-`denominator`. I.e. `new_ratio(2, 3)` will return a `Bernoulli` with a 2-in-3 chance, or about 67%, of returning `true`.",13,[[["u32"],["u32"]],["bernoulli"]]],[11,"sample","","",13,[[["self"],["r"]],["bool"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"clone","","",14,[[["self"]],["weightedindex"]]],[11,"new","","Creates a new a `WeightedIndex` [`Distribution`] using the values in `weights`. The weights can use any type `X` for which an implementation of [`Uniform<X>`] exists.",14,[[["i"]],["result",["weightedindex","weightederror"]]]],[11,"sample","","",14,[[["self"],["r"]],["usize"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"clone","","",5,[[["self"]],["weightederror"]]],[11,"eq","","",5,[[["self"],["weightederror"]],["bool"]]],[11,"description","","",5,[[["self"]],["str"]]],[11,"cause","","",5,[[["self"]],["option",["error"]]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"clone","","",15,[[["self"]],["unitspheresurface"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `UnitSphereSurface` distribution.",15,[[],["unitspheresurface"]]],[11,"sample","","",15,N],[11,"clone","","",16,[[["self"]],["unitcircle"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `UnitCircle` distribution.",16,[[],["unitcircle"]]],[11,"sample","","",16,N],[11,"clone","","",17,[[["self"]],["gamma"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct an object representing the `Gamma(shape, scale)` distribution.",17,[[["f64"],["f64"]],["gamma"]]],[11,"sample","","",17,[[["self"],["r"]],["f64"]]],[11,"clone","","",18,[[["self"]],["chisquared"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new chi-squared distribution with degrees-of-freedom `k`. Panics if `k < 0`.",18,[[["f64"]],["chisquared"]]],[11,"sample","","",18,[[["self"],["r"]],["f64"]]],[11,"clone","","",19,[[["self"]],["fisherf"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `FisherF` distribution, with the given parameter. Panics if either `m` or `n` are not positive.",19,[[["f64"],["f64"]],["fisherf"]]],[11,"sample","","",19,[[["self"],["r"]],["f64"]]],[11,"clone","","",20,[[["self"]],["studentt"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new Student t distribution with `n` degrees of freedom. Panics if `n <= 0`.",20,[[["f64"]],["studentt"]]],[11,"sample","","",20,[[["self"],["r"]],["f64"]]],[11,"clone","","",21,[[["self"]],["beta"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct an object representing the `Beta(alpha, beta)` distribution.",21,[[["f64"],["f64"]],["beta"]]],[11,"sample","","",21,[[["self"],["r"]],["f64"]]],[11,"clone","","",22,[[["self"]],["standardnormal"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"sample","","",22,[[["self"],["r"]],["f64"]]],[11,"clone","","",23,[[["self"]],["normal"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Normal` distribution with the given mean and standard deviation.",23,[[["f64"],["f64"]],["normal"]]],[11,"sample","","",23,[[["self"],["r"]],["f64"]]],[11,"clone","","",24,[[["self"]],["lognormal"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `LogNormal` distribution with the given mean and standard deviation.",24,[[["f64"],["f64"]],["lognormal"]]],[11,"sample","","",24,[[["self"],["r"]],["f64"]]],[11,"clone","","",25,[[["self"]],["exp1"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"sample","","",25,[[["self"],["r"]],["f64"]]],[11,"clone","","",26,[[["self"]],["exp"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Exp` with the given shape parameter `lambda`. Panics if `lambda <= 0`.",26,[[["f64"]],["exp"]]],[11,"sample","","",26,[[["self"],["r"]],["f64"]]],[11,"clone","","",27,[[["self"]],["pareto"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new Pareto distribution with given `scale` and `shape`.",27,[[["f64"],["f64"]],["pareto"]]],[11,"sample","","",27,[[["self"],["r"]],["f64"]]],[11,"clone","","",28,[[["self"]],["poisson"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Poisson` with the given shape parameter `lambda`. Panics if `lambda <= 0`.",28,[[["f64"]],["poisson"]]],[11,"sample","","",28,[[["self"],["r"]],["u64"]]],[11,"clone","","",29,[[["self"]],["binomial"]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Binomial` with the given shape parameters `n` (number of trials) and `p` (probability of success).",29,[[["u64"],["f64"]],["binomial"]]],[11,"sample","","",29,[[["self"],["r"]],["u64"]]],[11,"clone","","",30,[[["self"]],["cauchy"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Cauchy` with the given shape parameters `median` the peak location and `scale` the scale factor. Panics if `scale <= 0`.",30,[[["f64"],["f64"]],["cauchy"]]],[11,"sample","","",30,[[["self"],["r"]],["f64"]]],[11,"clone","","",31,[[["self"]],["dirichlet"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Dirichlet` with the given alpha parameter `alpha`.",31,[[["v"]],["dirichlet"]]],[11,"new_with_param","","Construct a new `Dirichlet` with the given shape parameter `alpha` and `size`.",31,[[["f64"],["usize"]],["dirichlet"]]],[11,"sample","","",31,[[["self"],["r"]],["vec",["f64"]]]],[11,"clone","","",32,[[["self"]],["triangular"]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Triangular` with minimum `min`, maximum `max` and mode `mode`.",32,[[["f64"],["f64"],["f64"]],["triangular"]]],[11,"sample","","",32,[[["self"],["r"]],["f64"]]],[11,"clone","","",33,[[["self"]],["weibull"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Weibull` distribution with given `scale` and `shape`.",33,[[["f64"],["f64"]],["weibull"]]],[11,"sample","","",33,[[["self"],["r"]],["f64"]]],[11,"clone","","",34,[[["self"]],["openclosed01"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"clone","","",35,[[["self"]],["open01"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"sample","","",36,[[["self"],["r"]],["f32"]]],[11,"sample","","",34,[[["self"],["r"]],["f32"]]],[11,"sample","","",35,[[["self"],["r"]],["f32"]]],[11,"sample","","",36,[[["self"],["r"]],["f64"]]],[11,"sample","","",34,[[["self"],["r"]],["f64"]]],[11,"sample","","",35,[[["self"],["r"]],["f64"]]],[11,"sample","","",36,[[["self"],["r"]],["f32x2"]]],[11,"sample","","",34,[[["self"],["r"]],["f32x2"]]],[11,"sample","","",35,[[["self"],["r"]],["f32x2"]]],[11,"sample","","",36,[[["self"],["r"]],["f32x4"]]],[11,"sample","","",34,[[["self"],["r"]],["f32x4"]]],[11,"sample","","",35,[[["self"],["r"]],["f32x4"]]],[11,"sample","","",36,[[["self"],["r"]],["f32x8"]]],[11,"sample","","",34,[[["self"],["r"]],["f32x8"]]],[11,"sample","","",35,[[["self"],["r"]],["f32x8"]]],[11,"sample","","",36,[[["self"],["r"]],["f32x16"]]],[11,"sample","","",34,[[["self"],["r"]],["f32x16"]]],[11,"sample","","",35,[[["self"],["r"]],["f32x16"]]],[11,"sample","","",36,[[["self"],["r"]],["f64x2"]]],[11,"sample","","",34,[[["self"],["r"]],["f64x2"]]],[11,"sample","","",35,[[["self"],["r"]],["f64x2"]]],[11,"sample","","",36,[[["self"],["r"]],["f64x4"]]],[11,"sample","","",34,[[["self"],["r"]],["f64x4"]]],[11,"sample","","",35,[[["self"],["r"]],["f64x4"]]],[11,"sample","","",36,[[["self"],["r"]],["f64x8"]]],[11,"sample","","",34,[[["self"],["r"]],["f64x8"]]],[11,"sample","","",35,[[["self"],["r"]],["f64x8"]]],[11,"sample","","",36,[[["self"],["r"]],["u8"]]],[11,"sample","","",36,[[["self"],["r"]],["u16"]]],[11,"sample","","",36,[[["self"],["r"]],["u32"]]],[11,"sample","","",36,[[["self"],["r"]],["u64"]]],[11,"sample","","",36,[[["self"],["r"]],["u128"]]],[11,"sample","","",36,[[["self"],["r"]],["usize"]]],[11,"sample","","",36,[[["self"],["r"]],["i8"]]],[11,"sample","","",36,[[["self"],["r"]],["i16"]]],[11,"sample","","",36,[[["self"],["r"]],["i32"]]],[11,"sample","","",36,[[["self"],["r"]],["i64"]]],[11,"sample","","",36,[[["self"],["r"]],["i128"]]],[11,"sample","","",36,[[["self"],["r"]],["isize"]]],[11,"sample","","",36,[[["self"],["r"]],["i8x2"]]],[11,"sample","","",36,[[["self"],["r"]],["u8x2"]]],[11,"sample","","",36,[[["self"],["r"]],["i16x2"]]],[11,"sample","","",36,[[["self"],["r"]],["u16x2"]]],[11,"sample","","",36,[[["self"],["r"]],["i8x4"]]],[11,"sample","","",36,[[["self"],["r"]],["u8x4"]]],[11,"sample","","",36,[[["self"],["r"]],["i32x2"]]],[11,"sample","","",36,[[["self"],["r"]],["u32x2"]]],[11,"sample","","",36,[[["self"],["r"]],["i16x4"]]],[11,"sample","","",36,[[["self"],["r"]],["u16x4"]]],[11,"sample","","",36,[[["self"],["r"]],["i8x8"]]],[11,"sample","","",36,[[["self"],["r"]],["u8x8"]]],[11,"sample","","",36,[[["self"],["r"]],["i64x2"]]],[11,"sample","","",36,[[["self"],["r"]],["u64x2"]]],[11,"sample","","",36,[[["self"],["r"]],["i32x4"]]],[11,"sample","","",36,[[["self"],["r"]],["u32x4"]]],[11,"sample","","",36,[[["self"],["r"]],["i16x8"]]],[11,"sample","","",36,[[["self"],["r"]],["u16x8"]]],[11,"sample","","",36,[[["self"],["r"]],["i8x16"]]],[11,"sample","","",36,[[["self"],["r"]],["u8x16"]]],[11,"sample","","",36,[[["self"],["r"]],["i64x4"]]],[11,"sample","","",36,[[["self"],["r"]],["u64x4"]]],[11,"sample","","",36,[[["self"],["r"]],["i32x8"]]],[11,"sample","","",36,[[["self"],["r"]],["u32x8"]]],[11,"sample","","",36,[[["self"],["r"]],["i16x16"]]],[11,"sample","","",36,[[["self"],["r"]],["u16x16"]]],[11,"sample","","",36,[[["self"],["r"]],["i8x32"]]],[11,"sample","","",36,[[["self"],["r"]],["u8x32"]]],[11,"sample","","",36,[[["self"],["r"]],["i64x8"]]],[11,"sample","","",36,[[["self"],["r"]],["u64x8"]]],[11,"sample","","",36,[[["self"],["r"]],["i32x16"]]],[11,"sample","","",36,[[["self"],["r"]],["u32x16"]]],[11,"sample","","",36,[[["self"],["r"]],["i16x32"]]],[11,"sample","","",36,[[["self"],["r"]],["u16x32"]]],[11,"sample","","",36,[[["self"],["r"]],["i8x64"]]],[11,"sample","","",36,[[["self"],["r"]],["u8x64"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"sample","","",36,[[["self"],["r"]],["char"]]],[11,"sample","","",37,[[["self"],["r"]],["char"]]],[11,"sample","","",36,[[["self"],["r"]],["bool"]]],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,N],[11,"sample","","",36,[[["self"],["r"]],["option"]]],[11,"sample","","",36,[[["self"],["r"]],["wrapping"]]],[8,"Distribution","","Types (distributions) that can be used to create a random instance of `T`.",N,N],[10,"sample","","Generate a random value of `T`, using `rng` as the source of randomness.",38,[[["self"],["r"]],["t"]]],[11,"sample_iter","","Create an iterator that generates random values of `T`, using `rng` as the source of randomness.",38,[[["self"],["r"]],["distiter"]]],[11,"fmt","","",39,[[["self"],["formatter"]],["result"]]],[11,"next","","",39,[[["self"]],["option"]]],[11,"size_hint","","",39,N],[11,"clone","","",36,[[["self"]],["standard"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"clone","","",4,[[["self"]],["weighted"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `WeightedChoice`.",40,N],[11,"sample","","",40,[[["self"],["r"]],["t"]]],[0,"prelude","rand","Convenience re-export of common members",N,N],[0,"prng","","Pseudo-random number generators.",N,N],[0,"chacha","rand::prng","The ChaCha random number generator.",N,N],[3,"ChaChaRng","rand::prng::chacha","A cryptographically secure random number generator that uses the ChaCha algorithm.",N,N],[3,"ChaChaCore","","The core of `ChaChaRng`, used with `BlockRng`.",N,N],[11,"clone","","",41,[[["self"]],["chacharng"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",41,[[["self"]],["u32"]]],[11,"next_u64","","",41,[[["self"]],["u64"]]],[11,"fill_bytes","","",41,N],[11,"try_fill_bytes","","",41,N],[11,"from_seed","","",41,N],[11,"from_rng","","",41,[[["r"]],["result",["error"]]]],[11,"get_word_pos","","Get the offset from the start of the stream, in 32-bit words.",41,[[["self"]],["u128"]]],[11,"set_word_pos","","Set the offset from the start of the stream, in 32-bit words.",41,[[["self"],["u128"]]]],[11,"set_stream","","Set the stream number.",41,[[["self"],["u64"]]]],[11,"clone","","",42,[[["self"]],["chachacore"]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result"]]],[11,"generate","","",42,N],[11,"from_seed","","",42,N],[11,"from","","",41,[[["chachacore"]],["self"]]],[0,"hc128","rand::prng","The HC-128 random number generator.",N,N],[3,"Hc128Rng","rand::prng::hc128","A cryptographically secure random number generator that uses the HC-128 algorithm.",N,N],[3,"Hc128Core","","The core of `Hc128Rng`, used with `BlockRng`.",N,N],[11,"clone","","",43,[[["self"]],["hc128rng"]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",43,[[["self"]],["u32"]]],[11,"next_u64","","",43,[[["self"]],["u64"]]],[11,"fill_bytes","","",43,N],[11,"try_fill_bytes","","",43,N],[11,"from_seed","","",43,N],[11,"from_rng","","",43,[[["r"]],["result",["error"]]]],[11,"clone","","",44,[[["self"]],["hc128core"]]],[11,"fmt","","",44,[[["self"],["formatter"]],["result"]]],[11,"generate","","",44,N],[11,"from_seed","","Create an HC-128 random number generator with a seed. The seed has to be 256 bits in length, matching the 128 bit `key` followed by 128 bit `iv` when HC-128 where to be used as a stream cipher.",44,N],[0,"rngs","rand","Random number generators and adapters for common usage:",N,N],[3,"JitterRng","rand::rngs","A true random number generator based on jitter in the CPU execution time, and jitter in memory access time.",N,N],[3,"EntropyRng","","An interface returning random data from external source(s), provided specifically for securely seeding algorithmic generators (PRNGs).",N,N],[3,"SmallRng","","An RNG recommended when small state, cheap initialization and good performance are required. The PRNG algorithm in `SmallRng` is chosen to be efficient on the current platform, without consideration for cryptography or security. The size of its state is much smaller than for [`StdRng`].",N,N],[3,"StdRng","","The standard RNG. The PRNG algorithm in `StdRng` is chosen to be efficient on the current platform, to be statistically strong and unpredictable (meaning a cryptographically secure PRNG).",N,N],[3,"ThreadRng","","The type returned by [`thread_rng`], essentially just a reference to the PRNG in thread-local memory.",N,N],[3,"OsRng","","A random number generator that retrieves randomness straight from the operating system.",N,N],[4,"TimerError","","An error that can occur when [`JitterRng::test_timer`] fails.",N,N],[13,"NoTimer","","No timer available.",45,N],[13,"CoarseTimer","","Timer too coarse to use as an entropy source.",45,N],[13,"NotMonotonic","","Timer is not monotonically increasing.",45,N],[13,"TinyVariantions","","Variations of deltas of time too small.",45,N],[13,"TooManyStuck","","Too many stuck results (indicating no added entropy).",45,N],[0,"adapter","","Wrappers / adapters forming RNGs",N,N],[3,"ReadRng","rand::rngs::adapter","An RNG that reads random bytes straight from any type supporting `std::io::Read`, for example files.",N,N],[3,"ReseedingRng","","A wrapper around any PRNG that implements [`BlockRngCore`], that adds the ability to reseed it.",N,N],[11,"fmt","","",46,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `ReadRng` from a `Read`.",46,[[["r"]],["readrng"]]],[11,"next_u32","","",46,[[["self"]],["u32"]]],[11,"next_u64","","",46,[[["self"]],["u64"]]],[11,"fill_bytes","","",46,N],[11,"try_fill_bytes","","",46,N],[11,"fmt","","",47,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `ReseedingRng` from an existing PRNG, combined with a RNG to use as reseeder.",47,[[["r"],["u64"],["rsdr"]],["self"]]],[11,"reseed","","Reseed the internal PRNG.",47,[[["self"]],["result",["error"]]]],[11,"next_u32","","",47,[[["self"]],["u32"]]],[11,"next_u64","","",47,[[["self"]],["u64"]]],[11,"fill_bytes","","",47,N],[11,"try_fill_bytes","","",47,N],[11,"clone","","",47,[[["self"]],["reseedingrng"]]],[11,"fmt","rand::rngs","",48,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `EntropyRng`.",48,[[],["self"]]],[11,"default","","",48,[[],["self"]]],[11,"next_u32","","",48,[[["self"]],["u32"]]],[11,"next_u64","","",48,[[["self"]],["u64"]]],[11,"fill_bytes","","",48,N],[11,"try_fill_bytes","","",48,N],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"clone","","",49,[[["self"]],["jitterrng"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"clone","","",45,[[["self"]],["timererror"]]],[11,"eq","","",45,[[["self"],["timererror"]],["bool"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"description","","",45,[[["self"]],["str"]]],[11,"from","rand","",3,[[["timererror"]],["error"]]],[11,"new","rand::rngs","Create a new `JitterRng`. Makes use of `std::time` for a timer, or a platform-specific function with higher accuracy if necessary and available.",49,[[],["result",["jitterrng","timererror"]]]],[11,"new_with_timer","","Create a new `JitterRng`. A custom timer can be supplied, making it possible to use `JitterRng` in `no_std` environments.",49,N],[11,"set_rounds","","Configures how many rounds are used to generate each 64-bit value. This must be greater than zero, and has a big impact on performance and output quality.",49,[[["self"],["u8"]]]],[11,"test_timer","","Basic quality tests on the timer, by measuring CPU timing jitter a few hundred times.",49,[[["self"]],["result",["u8","timererror"]]]],[11,"timer_stats","","Statistical test: return the timer delta of one normal run of the `JitterRng` entropy collector.",49,[[["self"],["bool"]],["i64"]]],[11,"next_u32","","",49,[[["self"]],["u32"]]],[11,"next_u64","","",49,[[["self"]],["u64"]]],[11,"fill_bytes","","",49,N],[11,"try_fill_bytes","","",49,N],[0,"mock","","Mock random number generator",N,N],[3,"StepRng","rand::rngs::mock","A simple implementation of `RngCore` for testing purposes.",N,N],[11,"fmt","","",50,[[["self"],["formatter"]],["result"]]],[11,"clone","","",50,[[["self"]],["steprng"]]],[11,"new","","Create a `StepRng`, yielding an arithmetic sequence starting with `initial` and incremented by `increment` each time.",50,[[["u64"],["u64"]],["self"]]],[11,"next_u32","","",50,[[["self"]],["u32"]]],[11,"next_u64","","",50,[[["self"]],["u64"]]],[11,"fill_bytes","","",50,N],[11,"try_fill_bytes","","",50,N],[11,"clone","rand::rngs","",51,[[["self"]],["smallrng"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",51,[[["self"]],["u32"]]],[11,"next_u64","","",51,[[["self"]],["u64"]]],[11,"fill_bytes","","",51,N],[11,"try_fill_bytes","","",51,N],[11,"from_seed","","",51,N],[11,"from_rng","","",51,[[["r"]],["result",["error"]]]],[11,"clone","","",52,[[["self"]],["stdrng"]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",52,[[["self"]],["u32"]]],[11,"next_u64","","",52,[[["self"]],["u64"]]],[11,"fill_bytes","","",52,N],[11,"try_fill_bytes","","",52,N],[11,"from_seed","","",52,N],[11,"from_rng","","",52,[[["r"]],["result",["error"]]]],[11,"clone","","",53,[[["self"]],["threadrng"]]],[11,"fmt","","",53,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",53,[[["self"]],["u32"]]],[11,"next_u64","","",53,[[["self"]],["u64"]]],[11,"fill_bytes","","",53,N],[11,"try_fill_bytes","","",53,N],[11,"clone","","",54,[[["self"]],["osrng"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `OsRng`.",54,[[],["result",["osrng","error"]]]],[11,"next_u32","","",54,[[["self"]],["u32"]]],[11,"next_u64","","",54,[[["self"]],["u64"]]],[11,"fill_bytes","","",54,N],[11,"try_fill_bytes","","",54,N],[0,"seq","rand","Functions for randomly accessing and sampling sequences.",N,N],[3,"SliceChooseIter","rand::seq","Iterator over multiple choices, as returned by `SliceRandom::choose_multiple.",N,N],[5,"sample_iter","","Randomly sample `amount` elements from a finite iterator.",N,[[["r"],["i"],["usize"]],["result",["vec","vec"]]]],[5,"sample_slice","","Randomly sample exactly `amount` values from `slice`.",N,N],[5,"sample_slice_ref","","Randomly sample exactly `amount` references from `slice`.",N,N],[0,"index","","Index sampling",N,N],[4,"IndexVec","rand::seq::index","A vector of indices.",N,N],[4,"IndexVecIter","","Return type of `IndexVec::iter`.",N,N],[4,"IndexVecIntoIter","","Return type of `IndexVec::into_iter`.",N,N],[5,"sample","","Randomly sample exactly `amount` distinct indices from `0..length`, and return them in random order (fully shuffled).",N,[[["r"],["usize"],["usize"]],["indexvec"]]],[11,"clone","","",55,[[["self"]],["indexvec"]]],[11,"fmt","","",55,[[["self"],["formatter"]],["result"]]],[11,"len","","Returns the number of indices",55,[[["self"]],["usize"]]],[11,"index","","Return the value at the given `index`.",55,[[["self"],["usize"]],["usize"]]],[11,"into_vec","","Return result as a `Vec<usize>`. Conversion may or may not be trivial.",55,[[["self"]],["vec",["usize"]]]],[11,"iter","","Iterate over the indices as a sequence of `usize` values",55,[[["self"]],["indexveciter"]]],[11,"into_iter","","Convert into an iterator over the indices as a sequence of `usize` values",55,[[["self"]],["indexvecintoiter"]]],[11,"eq","","",55,[[["self"],["indexvec"]],["bool"]]],[11,"from","","",55,[[["vec",["u32"]]],["self"]]],[11,"from","","",55,[[["vec",["usize"]]],["self"]]],[11,"fmt","","",56,[[["self"],["formatter"]],["result"]]],[11,"next","","",56,[[["self"]],["option",["usize"]]]],[11,"size_hint","","",56,N],[11,"clone","","",57,[[["self"]],["indexvecintoiter"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"next","","",57,[[["self"]],["option"]]],[11,"size_hint","","",57,N],[8,"SliceRandom","rand::seq","Extension trait on slices, providing random mutation and sampling methods.",N,N],[16,"Item","","The element type.",58,N],[10,"choose","","Returns a reference to one random element of the slice, or `None` if the slice is empty.",58,[[["self"],["r"]],["option"]]],[10,"choose_mut","","Returns a mutable reference to one random element of the slice, or `None` if the slice is empty.",58,[[["self"],["r"]],["option"]]],[10,"choose_multiple","","Produces an iterator that chooses `amount` elements from the slice at random without repeating any, and returns them in random order.",58,[[["self"],["r"],["usize"]],["slicechooseiter"]]],[10,"choose_weighted","","Similar to [`choose`], where the likelihood of each outcome may be specified. The specified function `weight` maps items `x` to a relative likelihood `weight(x)`. The probability of each item being selected is therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.",58,[[["self"],["r"],["f"]],["result",["weightederror"]]]],[10,"choose_weighted_mut","","Similar to [`choose_mut`], where the likelihood of each outcome may be specified. The specified function `weight` maps items `x` to a relative likelihood `weight(x)`. The probability of each item being selected is therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.",58,[[["self"],["r"],["f"]],["result",["weightederror"]]]],[10,"shuffle","","Shuffle a mutable slice in place.",58,[[["self"],["r"]]]],[10,"partial_shuffle","","Shuffle a slice in place, but exit early.",58,N],[8,"IteratorRandom","","Extension trait on iterators, providing random sampling methods.",N,N],[11,"choose","","Choose one element at random from the iterator. If you have a slice, it's significantly faster to call the [`choose`] or [`choose_mut`] functions using the slice instead.",59,[[["self"],["r"]],["option"]]],[11,"choose_multiple_fill","","Collects `amount` values at random from the iterator into a supplied buffer.",59,N],[11,"choose_multiple","","Collects `amount` values at random from the iterator into a vector.",59,[[["self"],["r"],["usize"]],["vec"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"next","","",60,[[["self"]],["option"]]],[11,"size_hint","","",60,N],[11,"len","","",60,[[["self"]],["usize"]]],[8,"Rng","rand","An automatically-implemented extension trait on [`RngCore`] providing high-level generic methods for sampling values and other convenience methods.",N,N],[11,"gen","","Return a random value supporting the [`Standard`] distribution.",61,[[["self"]],["t"]]],[11,"gen_range","","Generate a random value in the range [`low`, `high`), i.e. inclusive of `low` and exclusive of `high`.",61,[[["self"],["b1"],["b2"]],["t"]]],[11,"sample","","Sample a new value, using the given distribution.",61,[[["self"],["d"]],["t"]]],[11,"sample_iter","","Create an iterator that generates values using the given distribution.",61,[[["self"],["d"]],["distiter"]]],[11,"fill","","Fill `dest` entirely with random bytes (uniform value distribution), where `dest` is any type supporting [`AsByteSliceMut`], namely slices and arrays over primitive integer types (`i8`, `i16`, `u32`, etc.).",61,[[["self"],["t"]]]],[11,"try_fill","","Fill `dest` entirely with random bytes (uniform value distribution), where `dest` is any type supporting [`AsByteSliceMut`], namely slices and arrays over primitive integer types (`i8`, `i16`, `u32`, etc.).",61,[[["self"],["t"]],["result",["error"]]]],[11,"gen_bool","","Return a bool with a probability `p` of being true.",61,[[["self"],["f64"]],["bool"]]],[11,"gen_ratio","","Return a bool with a probability of `numerator/denominator` of being true. I.e. `gen_ratio(2, 3)` has chance of 2 in 3, or about 67%, of returning true. If `numerator == denominator`, then the returned value is guaranteed to be `true`. If `numerator == 0`, then the returned value is guaranteed to be `false`.",61,[[["self"],["u32"],["u32"]],["bool"]]],[11,"choose","","Return a random element from `values`.",61,N],[11,"choose_mut","","Return a mutable pointer to a random element from `values`.",61,N],[11,"shuffle","","Shuffle a mutable slice in place.",61,N],[8,"AsByteSliceMut","","Trait for casting types to byte slices",N,N],[10,"as_byte_slice_mut","","Return a mutable reference to self as a byte slice",62,N],[10,"to_le","","Call `to_le` on each element (i.e. byte-swap on Big Endian platforms).",62,[[["self"]]]],[8,"FromEntropy","","A convenience extension to [`SeedableRng`] allowing construction from fresh entropy. This trait is automatically implemented for any PRNG implementing [`SeedableRng`] and is not intended to be implemented by users.",N,N],[10,"from_entropy","","Creates a new instance, automatically seeded with fresh entropy.",63,[[],["self"]]],[11,"eq","","",2,[[["self"],["errorkind"]],["bool"]]],[11,"description","","",3,[[["self"]],["str"]]],[11,"cause","","",3,[[["self"]],["option",["error"]]]],[11,"clone","","",2,[[["self"]],["errorkind"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result",["error"]]]],[11,"read","","",0,N],[11,"should_retry","","True if this kind of error may resolve itself on retry.",2,[[["self"]],["bool"]]],[11,"should_wait","","True if we should retry but wait before retrying",2,[[["self"]],["bool"]]],[11,"description","","A description of this error kind",2,[[["self"]],["str"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from_cast","","",2,[[["t"]],["t"]]],[11,"cast","","",2,[[["self"]],["u"]]],[11,"into_bits","","",2,[[["self"]],["u"]]],[11,"from_bits","","",2,[[["t"]],["t"]]],[11,"new","","Create a new instance, with specified kind and a message.",3,[[["errorkind"],["str"]],["error"]]],[11,"with_cause","","Create a new instance, with specified kind, message, and a chained cause.",3,[[["errorkind"],["str"],["e"]],["error"]]],[11,"take_cause","","Take the cause, if any. This allows the embedded cause to be extracted. This uses `Option::take`, leaving `self` with no cause.",3,[[["self"]],["option",["box"]]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"to_string","","",3,[[["self"]],["string"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from_cast","","",3,[[["t"]],["t"]]],[11,"cast","","",3,[[["self"]],["u"]]],[11,"into_bits","","",3,[[["self"]],["u"]]],[11,"from_bits","","",3,[[["t"]],["t"]]],[11,"to_owned","rand::distributions::uniform","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from_cast","","",9,[[["t"]],["t"]]],[11,"cast","","",9,[[["self"]],["u"]]],[11,"into_bits","","",9,[[["self"]],["u"]]],[11,"from_bits","","",9,[[["t"]],["t"]]],[11,"from","rand::distributions","",39,[[["t"]],["t"]]],[11,"into_iter","","",39,[[["self"]],["i"]]],[11,"into","","",39,[[["self"]],["u"]]],[11,"try_from","","",39,[[["u"]],["result"]]],[11,"borrow","","",39,[[["self"]],["t"]]],[11,"borrow_mut","","",39,[[["self"]],["t"]]],[11,"try_into","","",39,[[["self"]],["result"]]],[11,"get_type_id","","",39,[[["self"]],["typeid"]]],[11,"from_cast","","",39,[[["t"]],["t"]]],[11,"cast","","",39,[[["self"]],["u"]]],[11,"into_bits","","",39,[[["self"]],["u"]]],[11,"from_bits","","",39,[[["t"]],["t"]]],[11,"to_owned","","",36,[[["self"]],["t"]]],[11,"clone_into","","",36,N],[11,"from","","",36,[[["t"]],["t"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"from_cast","","",36,[[["t"]],["t"]]],[11,"cast","","",36,[[["self"]],["u"]]],[11,"into_bits","","",36,[[["self"]],["u"]]],[11,"from_bits","","",36,[[["t"]],["t"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from_cast","","",4,[[["t"]],["t"]]],[11,"cast","","",4,[[["self"]],["u"]]],[11,"into_bits","","",4,[[["self"]],["u"]]],[11,"from_bits","","",4,[[["t"]],["t"]]],[11,"from","","",40,[[["t"]],["t"]]],[11,"into","","",40,[[["self"]],["u"]]],[11,"try_from","","",40,[[["u"]],["result"]]],[11,"borrow","","",40,[[["self"]],["t"]]],[11,"borrow_mut","","",40,[[["self"]],["t"]]],[11,"try_into","","",40,[[["self"]],["result"]]],[11,"get_type_id","","",40,[[["self"]],["typeid"]]],[11,"from_cast","","",40,[[["t"]],["t"]]],[11,"cast","","",40,[[["self"]],["u"]]],[11,"into_bits","","",40,[[["self"]],["u"]]],[11,"from_bits","","",40,[[["t"]],["t"]]],[11,"to_owned","rand::distributions::uniform","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"from_cast","","",10,[[["t"]],["t"]]],[11,"cast","","",10,[[["self"]],["u"]]],[11,"into_bits","","",10,[[["self"]],["u"]]],[11,"from_bits","","",10,[[["t"]],["t"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"from_cast","","",11,[[["t"]],["t"]]],[11,"cast","","",11,[[["self"]],["u"]]],[11,"into_bits","","",11,[[["self"]],["u"]]],[11,"from_bits","","",11,[[["t"]],["t"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"from_cast","","",12,[[["t"]],["t"]]],[11,"cast","","",12,[[["self"]],["u"]]],[11,"into_bits","","",12,[[["self"]],["u"]]],[11,"from_bits","","",12,[[["t"]],["t"]]],[11,"from_entropy","rand::prng::chacha","",41,[[],["r"]]],[11,"to_owned","","",41,[[["self"]],["t"]]],[11,"clone_into","","",41,N],[11,"from","","",41,[[["t"]],["t"]]],[11,"into","","",41,[[["self"]],["u"]]],[11,"try_from","","",41,[[["u"]],["result"]]],[11,"borrow","","",41,[[["self"]],["t"]]],[11,"borrow_mut","","",41,[[["self"]],["t"]]],[11,"try_into","","",41,[[["self"]],["result"]]],[11,"get_type_id","","",41,[[["self"]],["typeid"]]],[11,"from_cast","","",41,[[["t"]],["t"]]],[11,"cast","","",41,[[["self"]],["u"]]],[11,"into_bits","","",41,[[["self"]],["u"]]],[11,"from_bits","","",41,[[["t"]],["t"]]],[11,"from_entropy","","",42,[[],["r"]]],[11,"to_owned","","",42,[[["self"]],["t"]]],[11,"clone_into","","",42,N],[11,"from","","",42,[[["t"]],["t"]]],[11,"into","","",42,[[["self"]],["u"]]],[11,"try_from","","",42,[[["u"]],["result"]]],[11,"borrow","","",42,[[["self"]],["t"]]],[11,"borrow_mut","","",42,[[["self"]],["t"]]],[11,"try_into","","",42,[[["self"]],["result"]]],[11,"get_type_id","","",42,[[["self"]],["typeid"]]],[11,"from_cast","","",42,[[["t"]],["t"]]],[11,"cast","","",42,[[["self"]],["u"]]],[11,"into_bits","","",42,[[["self"]],["u"]]],[11,"from_bits","","",42,[[["t"]],["t"]]],[11,"from_entropy","rand::prng::hc128","",43,[[],["r"]]],[11,"to_owned","","",43,[[["self"]],["t"]]],[11,"clone_into","","",43,N],[11,"from","","",43,[[["t"]],["t"]]],[11,"into","","",43,[[["self"]],["u"]]],[11,"try_from","","",43,[[["u"]],["result"]]],[11,"borrow","","",43,[[["self"]],["t"]]],[11,"borrow_mut","","",43,[[["self"]],["t"]]],[11,"try_into","","",43,[[["self"]],["result"]]],[11,"get_type_id","","",43,[[["self"]],["typeid"]]],[11,"from_cast","","",43,[[["t"]],["t"]]],[11,"cast","","",43,[[["self"]],["u"]]],[11,"into_bits","","",43,[[["self"]],["u"]]],[11,"from_bits","","",43,[[["t"]],["t"]]],[11,"from_entropy","","",44,[[],["r"]]],[11,"to_owned","","",44,[[["self"]],["t"]]],[11,"clone_into","","",44,N],[11,"from","","",44,[[["t"]],["t"]]],[11,"into","","",44,[[["self"]],["u"]]],[11,"try_from","","",44,[[["u"]],["result"]]],[11,"borrow","","",44,[[["self"]],["t"]]],[11,"borrow_mut","","",44,[[["self"]],["t"]]],[11,"try_into","","",44,[[["self"]],["result"]]],[11,"get_type_id","","",44,[[["self"]],["typeid"]]],[11,"from_cast","","",44,[[["t"]],["t"]]],[11,"cast","","",44,[[["self"]],["u"]]],[11,"into_bits","","",44,[[["self"]],["u"]]],[11,"from_bits","","",44,[[["t"]],["t"]]],[11,"from","rand::rngs::adapter","",46,[[["t"]],["t"]]],[11,"into","","",46,[[["self"]],["u"]]],[11,"try_from","","",46,[[["u"]],["result"]]],[11,"borrow","","",46,[[["self"]],["t"]]],[11,"borrow_mut","","",46,[[["self"]],["t"]]],[11,"try_into","","",46,[[["self"]],["result"]]],[11,"get_type_id","","",46,[[["self"]],["typeid"]]],[11,"from_cast","","",46,[[["t"]],["t"]]],[11,"cast","","",46,[[["self"]],["u"]]],[11,"into_bits","","",46,[[["self"]],["u"]]],[11,"from_bits","","",46,[[["t"]],["t"]]],[11,"to_owned","rand::rngs::mock","",50,[[["self"]],["t"]]],[11,"clone_into","","",50,N],[11,"from","","",50,[[["t"]],["t"]]],[11,"into","","",50,[[["self"]],["u"]]],[11,"try_from","","",50,[[["u"]],["result"]]],[11,"borrow","","",50,[[["self"]],["t"]]],[11,"borrow_mut","","",50,[[["self"]],["t"]]],[11,"try_into","","",50,[[["self"]],["result"]]],[11,"get_type_id","","",50,[[["self"]],["typeid"]]],[11,"from_cast","","",50,[[["t"]],["t"]]],[11,"cast","","",50,[[["self"]],["u"]]],[11,"into_bits","","",50,[[["self"]],["u"]]],[11,"from_bits","","",50,[[["t"]],["t"]]],[11,"from","rand::seq","",60,[[["t"]],["t"]]],[11,"into_iter","","",60,[[["self"]],["i"]]],[11,"into","","",60,[[["self"]],["u"]]],[11,"try_from","","",60,[[["u"]],["result"]]],[11,"borrow","","",60,[[["self"]],["t"]]],[11,"borrow_mut","","",60,[[["self"]],["t"]]],[11,"try_into","","",60,[[["self"]],["result"]]],[11,"get_type_id","","",60,[[["self"]],["typeid"]]],[11,"from_cast","","",60,[[["t"]],["t"]]],[11,"cast","","",60,[[["self"]],["u"]]],[11,"into_bits","","",60,[[["self"]],["u"]]],[11,"from_bits","","",60,[[["t"]],["t"]]],[11,"to_owned","rand::seq::index","",55,[[["self"]],["t"]]],[11,"clone_into","","",55,N],[11,"from","","",55,[[["t"]],["t"]]],[11,"into","","",55,[[["self"]],["u"]]],[11,"try_from","","",55,[[["u"]],["result"]]],[11,"borrow","","",55,[[["self"]],["t"]]],[11,"borrow_mut","","",55,[[["self"]],["t"]]],[11,"try_into","","",55,[[["self"]],["result"]]],[11,"get_type_id","","",55,[[["self"]],["typeid"]]],[11,"from_cast","","",55,[[["t"]],["t"]]],[11,"cast","","",55,[[["self"]],["u"]]],[11,"into_bits","","",55,[[["self"]],["u"]]],[11,"from_bits","","",55,[[["t"]],["t"]]],[11,"from","","",56,[[["t"]],["t"]]],[11,"into_iter","","",56,[[["self"]],["i"]]],[11,"into","","",56,[[["self"]],["u"]]],[11,"try_from","","",56,[[["u"]],["result"]]],[11,"borrow","","",56,[[["self"]],["t"]]],[11,"borrow_mut","","",56,[[["self"]],["t"]]],[11,"try_into","","",56,[[["self"]],["result"]]],[11,"get_type_id","","",56,[[["self"]],["typeid"]]],[11,"from_cast","","",56,[[["t"]],["t"]]],[11,"cast","","",56,[[["self"]],["u"]]],[11,"into_bits","","",56,[[["self"]],["u"]]],[11,"from_bits","","",56,[[["t"]],["t"]]],[11,"to_owned","","",57,[[["self"]],["t"]]],[11,"clone_into","","",57,N],[11,"from","","",57,[[["t"]],["t"]]],[11,"into_iter","","",57,[[["self"]],["i"]]],[11,"into","","",57,[[["self"]],["u"]]],[11,"try_from","","",57,[[["u"]],["result"]]],[11,"borrow","","",57,[[["self"]],["t"]]],[11,"borrow_mut","","",57,[[["self"]],["t"]]],[11,"try_into","","",57,[[["self"]],["result"]]],[11,"get_type_id","","",57,[[["self"]],["typeid"]]],[11,"from_cast","","",57,[[["t"]],["t"]]],[11,"cast","","",57,[[["self"]],["u"]]],[11,"into_bits","","",57,[[["self"]],["u"]]],[11,"from_bits","","",57,[[["t"]],["t"]]]],"paths":[[8,"RngCore"],[8,"SeedableRng"],[4,"ErrorKind"],[3,"Error"],[3,"Weighted"],[4,"WeightedError"],[8,"SampleUniform"],[8,"UniformSampler"],[8,"SampleBorrow"],[3,"Uniform"],[3,"UniformInt"],[3,"UniformFloat"],[3,"UniformDuration"],[3,"Bernoulli"],[3,"WeightedIndex"],[3,"UnitSphereSurface"],[3,"UnitCircle"],[3,"Gamma"],[3,"ChiSquared"],[3,"FisherF"],[3,"StudentT"],[3,"Beta"],[3,"StandardNormal"],[3,"Normal"],[3,"LogNormal"],[3,"Exp1"],[3,"Exp"],[3,"Pareto"],[3,"Poisson"],[3,"Binomial"],[3,"Cauchy"],[3,"Dirichlet"],[3,"Triangular"],[3,"Weibull"],[3,"OpenClosed01"],[3,"Open01"],[3,"Standard"],[3,"Alphanumeric"],[8,"Distribution"],[3,"DistIter"],[3,"WeightedChoice"],[3,"ChaChaRng"],[3,"ChaChaCore"],[3,"Hc128Rng"],[3,"Hc128Core"],[4,"TimerError"],[3,"ReadRng"],[3,"ReseedingRng"],[3,"EntropyRng"],[3,"JitterRng"],[3,"StepRng"],[3,"SmallRng"],[3,"StdRng"],[3,"ThreadRng"],[3,"OsRng"],[4,"IndexVec"],[4,"IndexVecIter"],[4,"IndexVecIntoIter"],[8,"SliceRandom"],[8,"IteratorRandom"],[3,"SliceChooseIter"],[8,"Rng"],[8,"AsByteSliceMut"],[8,"FromEntropy"]]};
searchIndex["rand_core"]={"doc":"Random number generation traits","items":[[3,"Error","rand_core","Error type of random number generators",N,N],[12,"kind","","The error kind",0,N],[12,"msg","","The error message",0,N],[4,"ErrorKind","","Error kind which can be matched over.",N,N],[13,"Unavailable","","Feature is not available; not recoverable.",1,N],[13,"Unexpected","","General failure; there may be a chance of recovery on retry.",1,N],[13,"Transient","","A transient failure which likely can be resolved or worked around.",1,N],[13,"NotReady","","Not ready yet: recommended to try again a little later.",1,N],[11,"eq","","",1,[[["self"],["errorkind"]],["bool"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"clone","","",1,[[["self"]],["errorkind"]]],[11,"should_retry","","True if this kind of error may resolve itself on retry.",1,[[["self"]],["bool"]]],[11,"should_wait","","True if we should retry but wait before retrying",1,[[["self"]],["bool"]]],[11,"description","","A description of this error kind",1,[[["self"]],["str"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new instance, with specified kind and a message.",0,[[["errorkind"],["str"]],["self"]]],[11,"with_cause","","Create a new instance, with specified kind, message, and a chained cause.",0,[[["errorkind"],["str"],["e"]],["self"]]],[11,"take_cause","","Take the cause, if any. This allows the embedded cause to be extracted. This uses `Option::take`, leaving `self` with no cause.",0,[[["self"]],["option",["box"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"description","","",0,[[["self"]],["str"]]],[11,"cause","","",0,[[["self"]],["option",["stderror"]]]],[0,"block","","The `BlockRngCore` trait and implementation helpers",N,N],[3,"BlockRng","rand_core::block","A wrapper type implementing [`RngCore`] for some type implementing [`BlockRngCore`] with `u32` array buffer; i.e. this can be used to implement a full RNG from just a `generate` function.",N,N],[12,"core","","The core part of the RNG, implementing the `generate` function.",2,N],[3,"BlockRng64","","A wrapper type implementing [`RngCore`] for some type implementing [`BlockRngCore`] with `u64` array buffer; i.e. this can be used to implement a full RNG from just a `generate` function.",N,N],[12,"core","","The core part of the RNG, implementing the `generate` function.",3,N],[8,"BlockRngCore","","A trait for RNGs which do not generate random numbers individually, but in blocks (typically `[u32; N]`). This technique is commonly used by cryptographic RNGs to improve performance.",N,N],[16,"Item","","Results element type, e.g. `u32`.",4,N],[16,"Results","","Results type. This is the 'block' an RNG implementing `BlockRngCore` generates, which will usually be an array like `[u32; 16]`.",4,N],[10,"generate","","Generate a new block of results.",4,N],[11,"clone","","",2,[[["self"]],["blockrng"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `BlockRng` from an existing RNG implementing `BlockRngCore`. Results will be generated on first use.",2,[[["r"]],["blockrng"]]],[11,"index","","Get the index into the result buffer.",2,[[["self"]],["usize"]]],[11,"reset","","Reset the number of available results. This will force a new set of results to be generated on next use.",2,[[["self"]]]],[11,"generate_and_set","","Generate a new set of results immediately, setting the index to the given value.",2,[[["self"],["usize"]]]],[11,"next_u32","","",2,[[["self"]],["u32"]]],[11,"next_u64","","",2,[[["self"]],["u64"]]],[11,"fill_bytes","","",2,N],[11,"try_fill_bytes","","",2,N],[11,"from_seed","","",2,N],[11,"from_rng","","",2,[[["s"]],["result",["error"]]]],[11,"clone","","",3,[[["self"]],["blockrng64"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `BlockRng` from an existing RNG implementing `BlockRngCore`. Results will be generated on first use.",3,[[["r"]],["blockrng64"]]],[11,"index","","Get the index into the result buffer.",3,[[["self"]],["usize"]]],[11,"reset","","Reset the number of available results. This will force a new set of results to be generated on next use.",3,[[["self"]]]],[11,"generate_and_set","","Generate a new set of results immediately, setting the index to the given value.",3,[[["self"],["usize"]]]],[11,"next_u32","","",3,[[["self"]],["u32"]]],[11,"next_u64","","",3,[[["self"]],["u64"]]],[11,"fill_bytes","","",3,N],[11,"try_fill_bytes","","",3,N],[11,"from_seed","","",3,N],[11,"from_rng","","",3,[[["s"]],["result",["error"]]]],[0,"impls","rand_core","Helper functions for implementing `RngCore` functions.",N,N],[5,"next_u64_via_u32","rand_core::impls","Implement `next_u64` via `next_u32`, little-endian order.",N,[[["r"]],["u64"]]],[5,"fill_bytes_via_next","","Implement `fill_bytes` via `next_u64` and `next_u32`, little-endian order.",N,N],[5,"fill_via_u32_chunks","","Implement `fill_bytes` by reading chunks from the output buffer of a block based RNG.",N,N],[5,"fill_via_u64_chunks","","Implement `fill_bytes` by reading chunks from the output buffer of a block based RNG.",N,N],[5,"next_u32_via_fill","","Implement `next_u32` via `fill_bytes`, little-endian order.",N,[[["r"]],["u32"]]],[5,"next_u64_via_fill","","Implement `next_u64` via `fill_bytes`, little-endian order.",N,[[["r"]],["u64"]]],[0,"le","rand_core","Little-Endian utilities",N,N],[5,"read_u32_into","rand_core::le","Reads unsigned 32 bit integers from `src` into `dst`. Borrowed from the `byteorder` crate.",N,N],[5,"read_u64_into","","Reads unsigned 64 bit integers from `src` into `dst`. Borrowed from the `byteorder` crate.",N,N],[8,"RngCore","rand_core","The core of a random number generator.",N,N],[10,"next_u32","","Return the next random `u32`.",5,[[["self"]],["u32"]]],[10,"next_u64","","Return the next random `u64`.",5,[[["self"]],["u64"]]],[10,"fill_bytes","","Fill `dest` with random data.",5,N],[10,"try_fill_bytes","","Fill `dest` entirely with random data.",5,N],[8,"CryptoRng","","A marker trait used to indicate that an [`RngCore`] or [`BlockRngCore`] implementation is supposed to be cryptographically secure.",N,N],[8,"SeedableRng","","A random number generator that can be explicitly seeded.",N,N],[16,"Seed","","Seed type, which is restricted to types mutably-dereferencable as `u8` arrays (we recommend `[u8; N]` for some `N`).",6,N],[10,"from_seed","","Create a new PRNG using the given seed.",6,N],[11,"from_rng","","Create a new PRNG seeded from another `Rng`.",6,[[["r"]],["result",["error"]]]],[11,"read","","",5,N],[11,"to_owned","rand_core::block","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]]],"paths":[[3,"Error"],[4,"ErrorKind"],[3,"BlockRng"],[3,"BlockRng64"],[8,"BlockRngCore"],[8,"RngCore"],[8,"SeedableRng"]]};
searchIndex["rand_isaac"]={"doc":"The ISAAC and ISAAC-64 random number generators.","items":[[0,"isaac","rand_isaac","The ISAAC random number generator.",N,N],[3,"IsaacRng","rand_isaac::isaac","A random number generator that uses the ISAAC algorithm.",N,N],[3,"IsaacCore","","The core of `IsaacRng`, used with `BlockRng`.",N,N],[11,"clone","","",0,[[["self"]],["isaacrng"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",0,[[["self"]],["u32"]]],[11,"next_u64","","",0,[[["self"]],["u64"]]],[11,"fill_bytes","","",0,N],[11,"try_fill_bytes","","",0,N],[11,"from_seed","","",0,N],[11,"from_rng","","",0,[[["s"]],["result",["error"]]]],[11,"new_from_u64","","Create an ISAAC random number generator using an `u64` as seed. If `seed == 0` this will produce the same stream of random numbers as the reference implementation when used unseeded.",0,[[["u64"]],["self"]]],[11,"clone","","",1,[[["self"]],["isaaccore"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"generate","","Refills the output buffer, `results`. See also the pseudocode desciption of the algorithm in the [`IsaacRng`] documentation.",1,[[["self"],["isaacarray"]]]],[11,"from_seed","","",1,N],[11,"from_rng","","",1,[[["r"]],["result",["error"]]]],[0,"isaac64","rand_isaac","The ISAAC-64 random number generator.",N,N],[3,"Isaac64Rng","rand_isaac::isaac64","A random number generator that uses ISAAC-64, the 64-bit variant of the ISAAC algorithm.",N,N],[3,"Isaac64Core","","The core of `Isaac64Rng`, used with `BlockRng`.",N,N],[11,"clone","","",2,[[["self"]],["isaac64rng"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",2,[[["self"]],["u32"]]],[11,"next_u64","","",2,[[["self"]],["u64"]]],[11,"fill_bytes","","",2,N],[11,"try_fill_bytes","","",2,N],[11,"from_seed","","",2,N],[11,"from_rng","","",2,[[["s"]],["result",["error"]]]],[11,"new_from_u64","","Create an ISAAC-64 random number generator using an `u64` as seed. If `seed == 0` this will produce the same stream of random numbers as the reference implementation when used unseeded.",2,[[["u64"]],["self"]]],[11,"clone","","",3,[[["self"]],["isaac64core"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"generate","","Refills the output buffer, `results`. See also the pseudocode desciption of the algorithm in the [`Isaac64Rng`] documentation.",3,[[["self"],["isaacarray"]]]],[11,"new_from_u64","","Create an ISAAC-64 random number generator using an `u64` as seed. If `seed == 0` this will produce the same stream of random numbers as the reference implementation when used unseeded.",3,[[["u64"]],["self"]]],[11,"from_seed","","",3,N],[11,"from_rng","","",3,[[["r"]],["result",["error"]]]],[11,"try_from","rand_isaac::isaac","",0,[[["u"]],["result"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","rand_isaac::isaac64","",2,[[["u"]],["result"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N]],"paths":[[3,"IsaacRng"],[3,"IsaacCore"],[3,"Isaac64Rng"],[3,"Isaac64Core"]]};
searchIndex["rand_xorshift"]={"doc":"The xorshift random number generator.","items":[[3,"XorShiftRng","rand_xorshift","An Xorshift random number generator.",N,N],[11,"clone","","",0,[[["self"]],["xorshiftrng"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",0,[[["self"]],["u32"]]],[11,"next_u64","","",0,[[["self"]],["u64"]]],[11,"fill_bytes","","",0,N],[11,"try_fill_bytes","","",0,N],[11,"from_seed","","",0,N],[11,"from_rng","","",0,[[["r"]],["result",["error"]]]]],"paths":[[3,"XorShiftRng"]]};
initSearch(searchIndex);
